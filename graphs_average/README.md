1. **АРАТАКИ РЕЙГЕН** — дано дерево на `n` вершинах (ввели `m = n−1` рёбер), нужно вывести код Прюфера длины `n−2`. Сложность — эффективная реализация при больших ограничениях (`n` до `5·10^5`): нужно быстро поддерживать текущие степени, выбирать минимальный лист (обычно через `set`/min-heap), и корректно обновлять листья при удалении вершин.

2. **Истребители демонов** — по взвешенному неориентированному графу домов нужно найти минимальную суммарную длину дорог, чтобы можно было посетить все дома и вывести жителей, то есть вес минимального остовного дерева (MST). Сложность — классический MST (Краскал/Прим) с аккуратной обработкой входа; при `N ≤ 100` задача простая, но важно не ошибиться в объединении компонент.

3. **Ведьмина служба доставки** — найти минимальную протяженность маршрута, который позволит обойти все дома, при этом если дорога используется хотя бы раз, её длина считается один раз (то есть опять минимальный “набор дорог, чтобы связать все дома” → MST). Сложность — большие ограничения (`N ≤ 10^5`, `M ≤ 10^6`), поэтому нужен быстрый Краскал с DSU и сортировкой большого числа ребер, плюс осторожность с памятью.

4. **Очень яблок хочется...** — дан неориентированный граф, нужно вывести маршрут, который начинается в доме `1`, проходит по всем дорогам хотя бы один раз и возвращается в `1` (эйлеров цикл/обход всех рёбер); если это невозможно — вывести `:(`, а если возможно — при выборе следующего ребра предпочитать ребро с меньшим индексом во входе. Сложность — проверить эйлеровость (все степени чётные и нужная связность) и построить маршрут алгоритмом Хиерхольцера, соблюдая правило “минимального ребра”.

5. **Грязные делишки** — ориентированный граф “лестниц” (движение из комнаты в комнату по направлению); для каждого запроса `(a,b)` нужно ответить `YES`, если существует путь `a → b` и также обратный путь `b → a` (чтобы Тихиро смогла добежать и вернуться), иначе `NO`. Сложность — много рёбер и запросов (`M` до `10^6`, `Q` до `10^5`): решается через компоненту сильной связности (Косараджу/Тарьяна) и проверку `scc[a] == scc[b]` за `O(1)` на запрос.

6. **Мугивары** — есть `n` островов и `m` “течений”, каждое течение задаёт гиперребро: список островов, между любыми двумя из которых можно перемещаться за фиксированное время `t_i`; нужно минимальное время от острова `1` до острова `k`, иначе `-1`. Сложность — гиперграф: нельзя разворачивать каждое течение в полный граф (слишком много пар), поэтому обычно строят двудольный граф “остров–течение” и запускают Дейкстру, где переход “остров→течение” бесплатный, а “течение→остров” стоит `t_i` (или эквивалентная модель).
