1. **Фанаты Drives** — нужно реализовать свой стек (или очередь) на динамически расширяемом массиве без использования контейнеров STL: обрабатывать `n` операций вида `+ x` (положить чипсину сверху) и `-` (снять с вершины) и вывести все снятые значения в порядке удаления. Сложность в том, что операций до `10^6`, поэтому нужна амортизированная `O(1)` на операцию и аккуратная реаллокация/копирование памяти при расширении (плюс быстрый ввод/вывод).

2. **Беспорядки в больнице** — требуется реализовать собственную очередь на связном списке: операции `+ x` добавляют в конец очереди, `-` удаляет из начала, а удалённых нужно печатать по одному на строке. Сложность — в корректной работе с указателями (head/tail), управлении памятью на `10^6` операций и запрете на встроенные структуры данных.

3. **Т.О.Ч.К.А.** — дано `n` строк одинаковой длины `k`; сообщения сортируют “цифровой” (LSD) сортировкой по последним символам, но вы успеваете посмотреть только `t` символов с конца, поэтому нужно вывести порядок сообщений после `t` итераций такой стабильной сортировки (до добавления точек). Сложность — в необходимости стабильности на каждой итерации и в эффективности: общий объём `n*k < 10^7`, значит решение должно быть линейным по входу (обычно radix/counting по символам), без лишних аллокаций.

4. **Сокровища древних пирамид** — нужно смоделировать “стековый” рюкзак вместимости `M`: сначала он заполняется первыми `M` сокровищами, а дальше для каждого нового сокровища Лара берёт предмет с вершины и со дна и вместе с новым оставляет в рюкзаке два самых тяжёлых из этих трёх (укладывая их обратно в заданном порядке). Сложность — корректно симулировать эту необычную операцию при `N, M ≤ 10^5` и выбрать подходящую структуру (обычно дека/двусторонняя очередь), чтобы операции с верхом и дном были быстрыми.

5. **Делу время — потехе час!** — для каждого дня нужно вывести, через сколько дней встретится задача строго большей сложности, чем в текущий день; если такой не будет — `-1`. Сложность — большие ограничения (`n` до `10^6`), поэтому нужен линейный алгоритм `O(n)` (монотонный стек “следующего большего элемента”), а не перебор.

6. **Спасение земель Русских** — по уже отсортированным координатам `N` мест нужно посадить `K` бояр так, чтобы минимальное расстояние между любыми двумя было как можно больше, и вывести это максимальное минимальное расстояние. Сложность — типичная связка “бинпоиск по ответу + жадная проверка расстановки” (Aggressive cows): важно правильно проверять достижимость расстояния и не ошибиться в границах.

7. **Остаться в живых** — дан “забор” из `N` досок (ширина каждой 1) с разными длинами, можно укорачивать длинные и удалять доски, чтобы получить прямоугольный плот максимальной площади; нужно вывести максимальную площадь. Сложность — это по сути задача о максимальном прямоугольнике в гистограмме: требуется `O(n)` монотонный стек при `N ≤ 10^6`, аккуратная обработка границ и 64-bit арифметика для площади.

8. **Давай поженимся** — есть коэффициенты женщин и мужчин, совместимость пары — сумма коэффициентов, все `n^2` пар упорядочены по возрастанию совместимости; нужно найти `k`-ю по порядку сумму. Сложность — огромный размер множества пар (перебирать нельзя при `n ≤ 10^5`), поэтому обычно делают сортировки массивов и бинпоиск по значению суммы с подсчётом количества пар `≤ mid` за линейное/почти линейное время (двумя указателями).
