1. **Ёлки-палки 2.0** — по отсортированному массиву значений нужно построить бинарное дерево поиска, которое при этом остаётся “почти сбалансированным” (высоты любых двух веток отличаются не больше чем на 1), и вывести дерево в `preorder`; при нескольких вариантах выбирают тот, где корень каждого поддерева минимально возможный. Сложность — правильно выбрать элементы как корни (фактически “почти идеальное” BST из отсортированного массива с аккуратным правилом выбора середины) и вывести именно нужный вариант при `n` до `10^6` без рекурсии по глубине.

2. **Предки — наше всё** — нужно поддерживать множество целых чисел в виде BST с операциями `insert/delete/exists/next/prev`, где `next` и `prev` — ближайшие строго больше/меньше, либо `none`. Сложность — корректная реализация удаления (случаи 0/1/2 детей) и поиска преемника/предшественника; операций мало (≤ 100), но важно не ошибиться в граничных случаях.

3. **И здесь k-й максимум...** — обрабатываются `n` команд: добавить число, удалить число и запросить `k`-й максимум среди текущих значений; нужно отвечать на запросы. Сложность — хранить мультимножество с порядковой статистикой (k-й элемент) при `n ≤ 10^5`, обычно через сбалансированное дерево/treap/Fenwick по координатам, и аккуратно обрабатывать удаления.

4. **Ёлки-палки** — строится BST последовательными `insert` значений, затем нужно вывести для каждого уровня значение самой правой вершины (вид “справа”), начиная с уровня 1. Сложность — корректно построить дерево и пройти его по уровням (BFS) или хранить максимум глубины/последний в уровне; при `n ≤ 10^3` всё просто, но важно не перепутать уровни и “правую” вершину.

5. **Три друга** — у трёх студентов по `n` уникальных названий файлов; за каждую задачу начисляются баллы в зависимости от того, сколько студентов отправили файл с таким именем (1 → 3 балла этому, 2 → по 1 обоим, 3 → 0). Сложность — быстро посчитать пересечения множеств по строкам и аккуратно начислить очки, обычно через хэш-множества/сортировку; `n` до `10000`.

6. **Подельник** — даны три последовательности (preorder, inorder, postorder) для BST на `n` вершинах; нужно проверить, могут ли они одновременно быть обходами одного и того же дерева, и вывести `YES/NO`. Сложность — сделать проверку без построения дерева “в лоб” на огромном `n ≤ 10^7`: нужно линейная/почти линейная валидация (через свойства BST и согласованность обходов), с очень экономной памятью.

7. **Проверка сбалансированности** — дано описание BST через массив вершин: ключ и индексы левого/правого ребёнка; для каждой вершины нужно вывести баланс `B(v)=height(right)-height(left)`. Сложность — посчитать высоты снизу вверх за `O(n)` без рекурсии (глубина может быть большой), например топологическим проходом/стеком, и не переполнить память при `n ≤ 2*10^5`.

8. **Три друга 2: возвращение** — то же начисление баллов по совпадающим именам файлов, но `n` уже до `100000`, поэтому решения на медленных структурах начинают “сыпаться”. Сложность — оптимизировать учёт совпадений (хэширование строк/сортировка всех имён с пометкой владельца) и минимизировать накладные расходы на строки и ввод.
