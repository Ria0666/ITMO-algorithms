1. **Двоичный код Грея (доп. балл)** — нужно вывести все `2^n` двоичных строк длины `n` в порядке кода Грея, где соседние строки отличаются ровно в одном бите. Сложность — правильно сгенерировать последовательность без ошибок в порядке (обычно `g(i)=i^(i>>1)`) и вывести при `n ≤ 20` достаточно быстро и без лишней памяти.

2. **Пусть утро будет нежным!** — требуется смоделировать работу сжатия LZ78: для строки `s` последовательно выводить пары `(pos, next)`, где `pos` — индекс в словаре самого длинного найденного префикса текущего суффикса, а `next` — следующий символ после него. Сложность — эффективный поиск “самого длинного префикса в словаре” на `|s| ≤ 5*10^5` (обычно через trie/хэш-таблицы переходов) и аккуратное ведение нумерации фраз.

3. **Облачный кризис** — по строке `s` нужно посчитать длину её представления при оптимальном кодировании Хаффмана. Сложность — это задача на частоты символов: построить (или эквивалентно посчитать) сумму `freq * depth` через объединение двух минимальных частот в min-heap; важно обработать крайний случай с одним уникальным символом и уложиться по времени при `|s| ≤ 10^6`.

4. **Помогите Элли (доп. балл)** — дано `t` строк, закодированных алгоритмом Хэмминга; нужно найти и исправить возможную одиночную ошибку и восстановить исходное сообщение для каждой строки. Сложность — правильно вычислять синдром по контрольным битам, определить позицию ошибки (или отсутствие), исправить её и затем извлечь информационные биты, не путая индексацию и формат кодового слова.

5. **Тик-ток! Пост-Панк!** — нужно выполнить арифметическое кодирование строки `s` и вывести результат с точностью до `6` знака. Сложность — корректно посчитать вероятности/интервалы по частотам символов, аккуратно обновлять границы интервала без накопления ошибок (обычно через `long double` или рациональную арифметику) и правильно выбрать число внутри финального интервала, чтобы оно однозначно декодировалось.
