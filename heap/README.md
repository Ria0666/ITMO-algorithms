1. **Пирамида ли?** — дан массив `a[1..n]`, нужно проверить, является ли он неубывающей двоичной кучей: для каждого `i` выполняется `a[i] ≤ a[2i]` и `a[i] ≤ a[2i+1]`, если такие дети существуют. Сложность минимальная: один проход по `i=1..n`, аккуратно проверяя индексы, и уложиться в `O(n)` при `n ≤ 10^5`.

2. **Реализуйте приоритетную очередь** — требуется поддерживать несколько очередей (куч) с командами `create / insert / extract-min / merge / decrease-key`, причём размер любой кучи в процессе не превышает `10^6`. Сложность — в корректной реализации структуры, где `merge` должен быть эффективным, а `decrease-key` требует находить и “поднимать” элемент; обычно здесь и появляется фибоначчиева куча (или другая meldable-heap), плюс важен быстрый ввод/вывод при числе операций до `10^6`.

3. **Величайший кроссовер** — дано `n` весов сокровищ, нужно отсортировать их по неубыванию и вывести. Сложность не в идее, а в ограничении `n ≤ 10^5`: нужно написать нормальную сортировку (например, быструю/слиянием), а не `O(n^2)`, и корректно работать с отрицательными/большими значениями.

4. **NIGHTBUILD: управление памятью блоками** — есть блоки `1..30000`: `Time +` выделяет свободный блок с минимальным номером и делает его занятым на `L` минут; `Time . BlockNo` — попытка доступа: успешна (`+`), если блок ещё занят, и тогда продлевает занятость на `L`, иначе (`-`). Сложность — поддерживать два приоритета одновременно: “самый маленький свободный” (min-heap по номеру) и “какие блоки пора освобождать” (min-heap по времени), плюс корректно обрабатывать продления и “устаревшие” события освобождения.

5. **777: сумма огромных чисел** — нужно просуммировать `N` целых чисел, каждое до `10^1000` по модулю, и вывести итог. Сложность — числа не влезают ни в один стандартный тип, поэтому нужна длинная арифметика (сложение строк, учёт знака), и при `N` до `6 * 10^6` критична скорость ввода и линейная обработка без лишних аллокаций.

6. **Fib-Kernel: фибоначчиева куча (команды планировщика)** — то же командное API `create/insert/extract-min/merge/decrease-key`, но явно требуется структура с эффективным слиянием и уменьшением ключа (амортизированно). Сложность — реализовать корректные операции `cut/cascading cut` и `consolidate`, не утечь по памяти, не уйти в глубокую рекурсию, и выдержать до `10^6` команд при ключах до `10^9`.
